CMPH - C Minimal Perfect Hashing Library


%!includeconf: CONFIG.t2t

-------------------------------------------------------------------

==Motivation==

A perfect hash function maps a static set of n keys into a set of m integer numbers without collisions, where m is greater than or equal to n. If m is equal to n, the function is called minimal.

[Minimal perfect hash functions concepts.html] are widely used for memory efficient storage and fast retrieval of items from static sets, such as words in natural languages, reserved words in programming languages or interactive systems, universal resource locations (URLs) in Web search engines, or item sets in data mining techniques. Therefore, there are applications for minimal perfect hash functions in information retrieval systems, database systems, language translation systems, electronic commerce systems, compilers, operating systems, among others.

The use of minimal perfect hash functions is, until now, restricted to scenarios where the set of keys being hashed is small, because of the limitations of current algorithms. But in many cases, to deal with huge set of keys is crucial. So, this project gives to the free software community an API that will work with sets in the order of billion of keys.

Probably, the most interesting application for minimal perfect hash functions is its use as an indexing structure for databases. The most popular data structure used as an indexing structure in databases is the B+ tree. In fact, the B+ tree is very used for dynamic applications with frequent insertions and deletions of records. However, for applications with sporadic modifications and a huge number of queries the B+ tree is not the best option, because practical deployments of this structure are extremely complex, and perform poorly with very large sets of keys such as those required for the new frontiers [database applications http://acmqueue.com/modules.php?name=Content&pa=showpage&pid=299].

For example, in the information retrieval field, the work with huge collections is a daily task. The simple assignment of ids to web pages of a collection can be a challenging task. While traditional databases simply cannot handle more traffic once the working set of web page urls does not fit in main memory anymore, minimal perfect hash functions can easily scale to hundred of millions of entries, using stock hardware.

As there are lots of applications for minimal perfect hash functions, it is important to implement memory and time efficient algorithms for constructing such functions. The lack of similar libraries in the free software world has been the main motivation to create the C Minimal Perfect Hashing Library ([gperf is a bit different gperf.html], since it was conceived to create very fast perfect hash functions for small sets of keys and CMPH Library was conceived to create minimal perfect hash functions for very large sets of keys). C Minimal Perfect Hashing Library is a portable LGPLed library to generate and to work with very efficient minimal perfect hash functions.

-------------------------------------------------------------------

==Description==

The CMPH Library encapsulates the newest and more efficient algorithms in an easy-to-use, production-quality, fast API. The library was designed to work with big entries that cannot fit in the main memory. It has been used successfully for constructing minimal perfect hash functions for sets with more than 100 million of keys, and we intend to expand this number to the order of billion of keys. Although there is a lack of similar libraries, we can point out some of the distinguishable features of the CMPH Library:

- Fast.
- Space-efficient with main memory usage carefully documented.
- The best modern algorithms are available (or at least scheduled for implementation :-)).
- Works with in-disk key sets through of using the adapter pattern.
- Serialization of hash functions.
- Portable C code (currently works on GNU/Linux and WIN32 and is reported to work in OpenBSD and Solaris).
- Object oriented implementation.
- Easily extensible.
- Well encapsulated API aiming binary compatibility through releases.
- Free Software.


----------------------------------------

==Supported Algorithms==

 
%html% - [BMZ Algorithm bmz.html].
%txt% - BMZ Algorithm.
  A very fast algorithm based on cyclic random graphs to construct minimal
  perfect hash functions in linear time. The resulting functions are not order preserving and
  can be stored in only //4cn// bytes, where //c// is between 0.93 and 1.15. 
%html% - [External Memory Based Algorithm for sets in the order of billion of keys brz.html] 
%txt% - BMZ Algorithm.
  A very fast external memory based algorithm for constructing minimal perfect hash functions
  for sets in the order of billion of keys in linear time. The resulting functions are not order preserving and
  can be stored using just 8.1 bits per key.
%html% - [CHM Algorithm chm.html].
%txt% - CHM Algorithm.
  An algorithm based on acyclic random graphs to construct minimal
  perfect hash functions in linear time. The resulting functions are order preserving and
  are stored in //4cn// bytes, where //c// is greater than 2.

%html% [Click Here comparison.html] to see a comparison of the supported algorithms. 


----------------------------------------

==News for version 0.5==

- A thread safe vector adapter has been added.
- [A new algorithm for sets in the order of billion of keys that requires approximately 8.1 bits per key to store the resulting MPHFs. brz.html] 
- All reported bugs and suggestions have been corrected and included as well.


----------------------------------------

==News for version 0.4==

- Vector Adapter has been added.
- An optimized version of bmz (bmz8) for small set of keys (at most 256 keys) has been added.
- All reported bugs and suggestions have been corrected and included as well.


----------------------------------------

==News for version 0.3==

- New heuristic added to the bmz algorithm permits to generate a mphf with only
  //24.80n + O(1)// bytes. The resulting function can be stored in //3.72n// bytes.
%html% [click here bmz.html#heuristic] for details.


----------------------------------------

==Examples==

Using cmph is quite simple. Take a look.


```
#include <cmph.h>
#include <string.h>
// Create minimal perfect hash function from in-memory vector
int main(int argc, char **argv)
{
	// Creating a filled vector
	const char *vector[] = {"aaaaaaaaaa", "bbbbbbbbbb", "cccccccccc", "dddddddddd", "eeeeeeeeee",
				"ffffffffff", "gggggggggg", "hhhhhhhhhh", "iiiiiiiiii", "jjjjjjjjjj"};
	unsigned int nkeys = 10;
	// Source of keys
	cmph_io_adapter_t *source = cmph_io_vector_adapter((char **)vector, nkeys);
	
	//Create minimal perfect hash function using the default (chm) algorithm.
	cmph_config_t *config = cmph_config_new(source);
	cmph_t *hash = cmph_new(config);
	cmph_config_destroy(config);
	
	//Find key
	const char *key = "jjjjjjjjjj";
	unsigned int id = cmph_search(hash, key, strlen(key));
	fprintf(stderr, "Id:%u\n", id);
	//Destroy hash
	cmph_destroy(hash);
	cmph_io_vector_adapter_destroy(source);
	return 0;
}
```
Download [vector_adapter_ex1.c examples/vector_adapter_ex1.c]. This example does not work in version 0.3. You need to update the sources from CVS to make it works.
-------------------------------

```
#include <cmph.h>
#include <stdio.h>
#include <string.h>
 // Create minimal perfect hash function from in-disk keys using BMZ algorithm
int main(int argc, char **argv)
{
	//Open file with newline separated list of keys
	FILE * keys_fd = fopen("keys.txt", "r");
	cmph_t *hash = NULL;
	if (keys_fd == NULL)
	{
		fprintf(stderr, "File \"keys.txt\" not found\n");
		exit(1);
	}
	// Source of keys
	cmph_io_adapter_t *source = cmph_io_nlfile_adapter(keys_fd);
	
	cmph_config_t *config = cmph_config_new(source);
	cmph_config_set_algo(config, CMPH_BMZ);
	hash = cmph_new(config);
	cmph_config_destroy(config);
	
	//Find key
	const char *key = "jjjjjjjjjj";
	unsigned int id = cmph_search(hash, key, strlen(key));
	fprintf(stderr, "Id:%u\n", id);
	//Destroy hash
	cmph_destroy(hash);
	cmph_io_nlfile_adapter_destroy(source);
	fclose(keys_fd);
	return 0;
}
```
Download [file_adapter_ex2.c examples/file_adapter_ex2.c] and [keys.txt examples/keys.txt]
--------------------------------------

==The cmph application==

cmph is the name of both the library and the utility
application that comes with this package. You can use the cmph
application for constructing minimal perfect hash functions from the command line. 
The cmph utility
comes with a number of flags, but it is very simple to create and to query 
minimal perfect hash functions:

```
 $ # Using the chm algorithm (default one) for constructing a mphf for keys in file keys_file
 $ ./cmph -g keys_file
 $ # Query id of keys in the file keys_query
 $ ./cmph -m keys_file.mph keys_query
```

The additional options let you set most of the parameters you have
available through the C API. Below you can see the full help message for the 
utility.


```
 usage: cmph [-v] [-h] [-V] [-k nkeys] [-f hash_function] [-g [-c value][-s seed] ] [-a algorithm] [-M memory_in_MB] [-b BRZ_parameter] [-d tmp_dir] [-m file.mph] keysfile
 Minimum perfect hashing tool

  -h     print this help message
  -c     c value that determines the number of vertices in the graph
  -a     algorithm - valid values are
          * bmz
          * bmz8
          * chm
          * brz
  -f     hash function (may be used multiple times) - valid values are
          * djb2
          * fnv
          * jenkins
          * sdbm
  -V     print version number and exit
  -v     increase verbosity (may be used multiple times)
  -k     number of keys
  -g     generation mode
  -s     random seed
  -m     minimum perfect hash function file
  -M     main memory availability (in MB)
  -d     temporary directory used in brz algorithm
  -b     parmeter of BRZ algorithm to make the maximal number of keys in a bucket lower than 256
  keysfile       line separated file with keys

```

==Additional Documentation==

[FAQ faq.html]

==Downloads==

Use the project page at sourceforge: http://sf.net/projects/cmph


==License Stuff==

Code is under the LGPL. 
----------------------------------------

%!include: FOOTER.t2t

%!include(html): ''LOGO.t2t''
Last Updated: %%date(%c)
